/**
 * @author V. H.
 * @file rgl.ts
 * @since 2020
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const util = tslib_1.__importStar(require("util"));
const fs = tslib_1.__importStar(require("fs-extra"));
const assert = tslib_1.__importStar(require("assert"));
const path = tslib_1.__importStar(require("path"));
const event = tslib_1.__importStar(require("events"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const string_decoder_1 = require("string_decoder");
const debug = util.debuglog("RGL"), debug_v = util.debuglog("RGLv"), debug_e = util.debuglog("RGLe"), voidfn = () => { };
var rgl;
(function (rgl) {
    debug("RGL loaded.");
    const _mappings_c = require(path.resolve(__dirname, "..", "..", "RGLMappings_c.js")), _mappings_b = require(path.resolve(__dirname, "..", "..", "RGLMappings_b.js")), _mappings_s = require(path.resolve(__dirname, "..", "..", "RGLMappings_s.js"));
    /**
     * Container of Errors.
     */
    let Errors;
    (function (Errors) {
        Errors.ENOBIN = new TypeError("Buffer is not binary.");
        Errors.ENOBUF = new TypeError("Not a Buffer.");
        Errors.EBADBUF = new RangeError("Bad data, Wrong size or format.");
        Errors.EBADTPYE = new TypeError("Bad parameter type.");
        Errors.ENOTTY = new TypeError("Not a TTY.");
    })(Errors = rgl.Errors || (rgl.Errors = {})); //Errors
    /**
     * Responsible for representing Chunks.
     */
    class RGLTile {
        constructor(origin) {
            this.origin = origin;
            this.precalc = "";
            this._id = RGLTile._idcntr++;
            assert.ok(origin.length == 8, Errors.EBADBUF);
            this.origin = Buffer.from(origin);
            this.precalc = (RGLTile.mappings_s.get(origin[6]) || (t => t))((RGLTile.mappings_b.get(origin[5]) || (t => t))((RGLTile.mappings_c.get(origin[4]) || (t => t))(RGLTile.decoder.write(origin.slice(0, 4)).replace(RGLTile.trim, ''))));
            this.reserved = origin[7];
        } //ctor
        get serialize() {
            return Buffer.from(this.origin);
        } //serialize
        static parse(chunk) {
            return new RGLTile(chunk);
        } //parse
        toString() {
            return this.precalc;
        } //toString
        [Symbol.toPrimitive](hint) {
            if (hint === "string")
                return this.toString();
            else
                return this;
        }
    } //RGLTile
    RGLTile.decoder = new string_decoder_1.StringDecoder("utf8");
    RGLTile.trim = /\u0000/gim;
    RGLTile._idcntr = 0;
    /**
     * Responsible for parsing and stripping Chunks.
     */
    class RGLMap {
        constructor(reserved = Buffer.alloc(3, 0), size = Buffer.alloc(2, 0), tiles = [], trailing = Buffer.allocUnsafe(0), _fromFile = "") {
            this.reserved = reserved;
            this.size = size;
            this.tiles = tiles;
            this.trailing = trailing;
            this._fromFile = _fromFile;
            this._id = RGLMap._idcntr++;
            this._fromFile = path.resolve(path.normalize(_fromFile));
        } //ctor
        get serialize() {
            let ret = Buffer.concat([this.reserved, RGLMap.RGL, this.size]);
            for (let tile of this.tiles)
                ret = Buffer.concat([ret, tile.serialize]);
            return Buffer.concat([ret, RGLMap.MAGIC, this.trailing]);
        } //serialize
        /**
         * Store 'T' to writable 'file'.
         *
         * @param file - Target file
         */
        async serializeFile(file = this._fromFile) {
            let data;
            await fs.outputFile(file, data = this.serialize, {
                mode: 0o751,
                encoding: "binary",
                flag: "w"
            });
            return data;
        } //serializeFile
        static parse(data) {
            debug(`RGLMap.parse`);
            assert.ok(Buffer.isBuffer(data), Errors.ENOBUF);
            assert.ok(Buffer.isEncoding("binary"), Errors.ENOBIN);
            assert.ok(data.length >= 9, Errors.EBADBUF);
            const map = new RGLMap(data.slice(0, 3), data.slice(7, 9));
            let idx = 9;
            while (idx < data.length && !data.slice(idx, idx + 5).equals(RGLMap.MAGIC))
                map.tiles.push(RGLTile.parse(data.slice(idx, idx += 8)));
            if (idx != data.length)
                map.trailing = data.slice(idx + 5);
            return map;
        } //parse
        /**
         * Read Buffer from 'file'.
         *
         * @param file - Target file
         */
        static async parseFile(file) {
            debug(`RGLMap.parseFile: ${file}`);
            return new Promise(async (res, rej) => {
                debug_v(`RGLMap.parseFile: ACCESS`);
                fs.access(file, fs.constants.F_OK | fs.constants.R_OK, err => {
                    if (err) {
                        debug_e(`RGLMap.parseFile: ${file} -> EACCESS`);
                        rej(err);
                    }
                    else {
                        debug_v(`RGLMap.parseFile: RSTREAM`);
                        const str = fs.createReadStream(file, {
                            flags: "r",
                            encoding: "binary",
                            mode: fs.constants.S_IRUSR | fs.constants.S_IXGRP,
                            emitClose: true
                        })
                            .once("readable", async () => {
                            debug_v(`RGLMap.parseFile: ${file} -> Readable.`);
                            let data = '';
                            str.setEncoding("binary");
                            for await (let chunk of str)
                                data += chunk;
                            str.once("close", () => {
                                const map = RGLMap.parse(Buffer.from(data, "binary"));
                                map._fromFile = file;
                                res(map);
                            });
                        });
                    }
                });
            });
        } //parseFile
        toString() {
            return this.tiles.map((tile) => tile.toString()).join('');
        } //toString
        [Symbol.toPrimitive](hint) {
            if (hint === "string")
                return this.toString();
            else
                return this;
        }
    } //RGLMap
    RGLMap.MAGIC = Buffer.from([0x03, 0x00, 0x00, 0x00, 0x01]);
    RGLMap.RGL = Buffer.from([0x52, 0x47, 0x4C, 0x02]);
    RGLMap._idcntr = 0;
    /**
     * Responsible for controlling transitions and settings.
     *
     * TODO: Add controls.
     */
    class RGL extends event.EventEmitter {
        constructor(autoconfig = true, mappings_c = _mappings_c, mappings_b = _mappings_b, _Map = RGLMap, _Tile = RGLTile) {
            super();
            this.mappings_c = mappings_c;
            this.mappings_b = mappings_b;
            this._Map = _Map;
            this._Tile = _Tile;
            this.secureSwitch = true;
            this.binds = null;
            if (!chalk_1.default.supportsColor)
                console.warn("Terminal colors are not supported!");
            this.mappings_c = new Map(mappings_c);
            this.mappings_b = new Map(mappings_b);
            if (autoconfig) {
                Promise.all([
                    this.loadMappings_c(),
                    this.loadMappings_b()
                ]).catch(() => debug_e("RGL.autoconf: EMAPPING")).then(() => {
                    this._Tile.mappings_c = this.mappings_c;
                    this._Tile.mappings_b = this.mappings_b;
                    debug("RGL.ctor deffered mappings.");
                });
                this.bind();
            }
            this._Tile.mappings_c = this.mappings_c;
            this._Tile.mappings_b = this.mappings_b;
            this._Tile.mappings_s = RGL.mappings_s;
        } //ctor
        loadMappings_c(map = "RGLMappings_c.js") {
            this.emit("_loadColors", map);
            return RGL.loadMappings(map, this.mappings_c);
        } //loadMappings_c
        loadMappings_b(map = "RGLMappings_b.js") {
            this.emit("_loadBackground", map);
            return RGL.loadMappings(map, this.mappings_b);
        } //loadMappings_c
        /**
         * Include custom mappings.
         *
         * @param map - Load new mappings
         * @param orig - Mappings to override
         */
        static async loadMappings(map, orig) {
            debug("RGL.loadMappings:", util.inspect(orig, { breakLength: Infinity }));
            if (typeof map === "string") {
                delete require.cache[require.resolve(map)];
                const data = require(map);
                for (let sig of data)
                    orig.set(sig[0], sig[1]);
            }
            else if (map instanceof Map) {
                for (let sig of map)
                    orig.set(sig[0], sig[1]);
            }
            else
                throw Errors.EBADTPYE;
            return orig;
        } //loadMappings
        /**
         * Bind the RGL engine to I/O.
         *
         * @param inp - The target user-input stream to bind, must be a TTY
         * @param out - The target user-input stream to bind, must be a TTY
         */
        bind(inp = (this.binds ? this.binds.input : process.stdin) || process.stdin, out = (this.binds ? this.binds.output : process.stdout) || process.stdout) {
            debug("RGL.bind: " + this.binds);
            assert.ok(inp.isTTY && out.isTTY, Errors.ENOTTY);
            if (!!this.binds && !!this.binds.input) {
                debug("RGL.bind unbound.");
                this.binds.input.setRawMode(false);
                if (!!this.binds._inpCb)
                    this.binds.input.removeListener("data", this.binds._inpCb);
            }
            this.binds = {
                input: inp,
                output: out,
                error: process.stderr
            };
            this.binds.input.setRawMode(true);
            this.binds.input.on("data", this.binds._inpCb = data => {
                this.emit("rawkey", data);
                this.emit("key", data.toString());
                if (this.secureSwitch && data.toString() === '\u0003') {
                    this.emit("_exit");
                    process.exit();
                }
            });
            return this;
        } //bind
        /**
         * Start an instance of RGL.
         *
         * @param {any[]} params - Options passed to constructor
         */
        static create(...params) {
            return new RGL(...params);
        } //create
    } //RGL
    RGL.mappings_s = new Map(_mappings_s);
    rgl.RGL = RGL;
})(rgl = exports.rgl || (exports.rgl = {})); //rgl
exports.default = rgl;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmdsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vbGliL3JnbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7OztHQUlHO0FBRUgsWUFBWSxDQUFDOzs7QUFFYixtREFBNkI7QUFDN0IscURBQStCO0FBQy9CLHVEQUFpQztBQUNqQyxtREFBNkI7QUFFN0Isc0RBQWdDO0FBQ2hDLDBEQUEwQjtBQUMxQixtREFBK0M7QUFFL0MsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFDakMsT0FBTyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQy9CLE9BQU8sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxFQUMvQixNQUFNLEdBQWUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBRWhDLElBQWMsR0FBRyxDQWlYaEI7QUFqWEQsV0FBYyxHQUFHO0lBQ2hCLEtBQUssQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUdyQixNQUFNLFdBQVcsR0FBeUIsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsa0JBQWtCLENBQUMsQ0FBQyxFQUN6RyxXQUFXLEdBQXlCLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLGtCQUFrQixDQUFDLENBQUMsRUFDcEcsV0FBVyxHQUE0QixPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxrQkFBa0IsQ0FBQyxDQUFDLENBQUM7SUFHekc7O09BRUc7SUFDSCxJQUFpQixNQUFNLENBTXRCO0lBTkQsV0FBaUIsTUFBTTtRQUNULGFBQU0sR0FBRyxJQUFJLFNBQVMsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO1FBQ2hELGFBQU0sR0FBRyxJQUFJLFNBQVMsQ0FBQyxlQUFlLENB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clxuICogQGF1dGhvciBWLiBILlxyXG4gKiBAZmlsZSByZ2wudHNcclxuICogQHNpbmNlIDIwMjBcclxuICovXHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSBcInV0aWxcIjtcclxuaW1wb3J0ICogYXMgZnMgZnJvbSBcImZzLWV4dHJhXCI7XHJcbmltcG9ydCAqIGFzIGFzc2VydCBmcm9tIFwiYXNzZXJ0XCI7XHJcbmltcG9ydCAqIGFzIHBhdGggZnJvbSBcInBhdGhcIjtcclxuaW1wb3J0ICogYXMgdHR5IGZyb20gXCJ0dHlcIjtcclxuaW1wb3J0ICogYXMgZXZlbnQgZnJvbSBcImV2ZW50c1wiO1xyXG5pbXBvcnQgY2hhbGsgZnJvbSBcImNoYWxrXCI7XHJcbmltcG9ydCB7IFN0cmluZ0RlY29kZXIgfSBmcm9tIFwic3RyaW5nX2RlY29kZXJcIjtcclxuXHJcbmNvbnN0IGRlYnVnID0gdXRpbC5kZWJ1Z2xvZyhcIlJHTFwiKSxcclxuXHRkZWJ1Z192ID0gdXRpbC5kZWJ1Z2xvZyhcIlJHTHZcIiksXHJcblx0ZGVidWdfZSA9IHV0aWwuZGVidWdsb2coXCJSR0xlXCIpLFxyXG5cdHZvaWRmbjogKCkgPT4gdm9pZCA9ICgpID0+IHsgfTtcclxuXHJcbmV4cG9ydCBtb2R1bGUgcmdsIHtcclxuXHRkZWJ1ZyhcIlJHTCBsb2FkZWQuXCIpO1xyXG5cclxuXHJcblx0Y29uc3QgX21hcHBpbmdzX2M6IE1hcDxudW1iZXIsIE1hcHBpbmc+ID0gcmVxdWlyZShwYXRoLnJlc29sdmUoX19kaXJuYW1lLCBcIi4uXCIsIFwiLi5cIiwgXCJSR0xNYXBwaW5nc19jLmpzXCIpKSxcclxuXHRcdF9tYXBwaW5nc19iOiBNYXA8bnVtYmVyLCBNYXBwaW5nPiA9IHJlcXVpcmUocGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgXCIuLlwiLCBcIi4uXCIsIFwiUkdMTWFwcGluZ3NfYi5qc1wiKSksXHJcblx0XHRfbWFwcGluZ3NfczogTWFwIDwgbnVtYmVyLCBNYXBwaW5nID4gPSByZXF1aXJlKHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsIFwiLi5cIiwgXCIuLlwiLCBcIlJHTE1hcHBpbmdzX3MuanNcIikpO1xyXG5cdFxyXG5cclxuXHQvKipcclxuXHQgKiBDb250YWluZXIgb2YgRXJyb3JzLlxyXG5cdCAqL1xyXG5cdGV4cG9ydCBuYW1lc3BhY2UgRXJyb3JzIHtcclxuXHRcdGV4cG9ydCBjb25zdCBFTk9CSU4gPSBuZXcgVHlwZUVycm9yKFwiQnVmZmVyIGlzIG5vdCBiaW5hcnkuXCIpO1xyXG5cdFx0ZXhwb3J0IGNvbnN0IEVOT0JVRiA9IG5ldyBUeXBlRXJyb3IoXCJOb3QgYSBCdWZmZXIuXCIpO1xyXG5cdFx0ZXhwb3J0IGNvbnN0IEVCQURCVUYgPSBuZXcgUmFuZ2VFcnJvcihcIkJhZCBkYXRhLCBXcm9uZyBzaXplIG9yIGZvcm1hdC5cIik7XHJcblx0XHRleHBvcnQgY29uc3QgRUJBRFRQWUUgPSBuZXcgVHlwZUVycm9yKFwiQmFkIHBhcmFtZXRlciB0eXBlLlwiKTtcclxuXHRcdGV4cG9ydCBjb25zdCBFTk9UVFkgPSBuZXcgVHlwZUVycm9yKFwiTm90IGEgVFRZLlwiKTtcclxuXHR9IC8vRXJyb3JzXHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnRhaW5lciBvZiBBRFQgY29udHJhY3RzLlxyXG5cdCAqL1xyXG5cdGV4cG9ydCBuYW1lc3BhY2UgVHlwZXMge1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQW55dGhpbmcgdGhhdCBjYW4gYmUgc2VyaWFsaXplZCBhbmQgcGFyc2VkLlxyXG5cdFx0ICovXHJcblx0XHRleHBvcnQgaW50ZXJmYWNlIENvbnZlcnRhYmxlIHtcclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIENvbnZlcnQgJ1QnIHRvIHdyaXRhYmxlIEJ1ZmZlci5cclxuXHRcdFx0ICovXHJcblx0XHRcdHNlcmlhbGl6ZTogQnVmZmVyO1xyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogQ29udmVydCBCdWZmZXIgdG8gJ1QnLlxyXG5cdFx0XHQgKiBcclxuXHRcdFx0ICogQHBhcmFtIGRhdGEgLSBTdHJpY3RseSBhIGJpbmFyeSBidWZmZXJcclxuXHRcdFx0ICovXHJcblx0XHRcdHBhcnNlPyhkYXRhOiBSZWFkb25seTxCdWZmZXI+KTogQ29udmVydGFibGU7XHJcblx0XHR9IC8vQ29udmVydGFibGVcclxuXHJcblx0fSAvL1R5cGVzXHJcblxyXG5cclxuXHQvKipcclxuXHQgKiAnQ2xhc3MnIHR5cGUuXHJcblx0ICovXHJcblx0dHlwZSBDbGFzczxUPiA9IG5ldyAoLi4uYXJnczogYW55W10pID0+IFQ7XHJcblx0LyoqXHJcblx0ICogSS9PIGJpbmRpbmcgdHlwZS5cclxuXHQgKi9cclxuXHR0eXBlIElPID0ge1xyXG5cdFx0aW5wdXQ6IE5vZGVKUy5SZWFkU3RyZWFtO1xyXG5cdFx0b3V0cHV0OiBOb2RlSlMuV3JpdGVTdHJlYW07XHJcblx0XHRlcnJvcj86IE5vZGVKUy5SZWFkV3JpdGVTdHJlYW07XHJcblx0XHRfaW5wQ2I/OiAoZGF0YTogQnVmZmVyKSA9PiB2b2lkO1xyXG5cdH07XHJcblx0LyoqXHJcblx0ICogJ01hcHBpbmcnIHR5cGUuXHJcblx0ICovXHJcblx0ZXhwb3J0IHR5cGUgTWFwcGluZyA9ICh0ZXh0OiBzdHJpbmcpID0+IHN0cmluZztcclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlc3BvbnNpYmxlIGZvciByZXByZXNlbnRpbmcgQ2h1bmtzLlxyXG5cdCAqL1xyXG5cdGNsYXNzIFJHTFRpbGUgaW1wbGVtZW50cyBUeXBlcy5Db252ZXJ0YWJsZSB7XHJcblxyXG5cdFx0cHVibGljIHN0YXRpYyBkZWNvZGVyOiBTdHJpbmdEZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoXCJ1dGY4XCIpO1xyXG5cdFx0c3RhdGljIG1hcHBpbmdzX2M6IE1hcDxudW1iZXIsIE1hcHBpbmc+O1xyXG5cdFx0c3RhdGljIG1hcHBpbmdzX2I6IE1hcDxudW1iZXIsIE1hcHBpbmc+O1xyXG5cdFx0c3RhdGljIG1hcHBpbmdzX3M6IE1hcDxudW1iZXIsIE1hcHBpbmc+O1xyXG5cdFx0cHJpdmF0ZSBzdGF0aWMgdHJpbTogUmVnRXhwID0gL1xcdTAwMDAvZ2ltO1xyXG5cdFx0cHJpdmF0ZSBzdGF0aWMgX2lkY250cjogbnVtYmVyID0gMDtcclxuXHJcblx0XHRwcm90ZWN0ZWQgcHJlY2FsYzogc3RyaW5nID0gXCJcIjtcclxuXHRcdHByaXZhdGUgcmVzZXJ2ZWQ6IG51bWJlcjtcclxuXHRcdHByb3RlY3RlZCByZWFkb25seSBfaWQ6IG51bWJlciA9IFJHTFRpbGUuX2lkY250cisrO1xyXG5cclxuXHJcblx0XHRwcm90ZWN0ZWQgY29uc3RydWN0b3IocHJvdGVjdGVkIHJlYWRvbmx5IG9yaWdpbjogUmVhZG9ubHk8QnVmZmVyPikge1xyXG5cdFx0XHRhc3NlcnQub2sob3JpZ2luLmxlbmd0aCA9PSA4LCBFcnJvcnMuRUJBREJVRik7XHJcblxyXG5cdFx0XHR0aGlzLm9yaWdpbiA9IEJ1ZmZlci5mcm9tKG9yaWdpbik7XHJcblx0XHRcdHRoaXMucHJlY2FsYyA9IChSR0xUaWxlLm1hcHBpbmdzX3MuZ2V0KG9yaWdpbls2XSkgfHwgKHQgPT4gdCkpKChSR0xUaWxlLm1hcHBpbmdzX2IuZ2V0KG9yaWdpbls1XSkgfHwgKHQgPT4gdCkpKChSR0xUaWxlLm1hcHBpbmdzX2MuZ2V0KG9yaWdpbls0XSkgfHwgKHQgPT4gdCkpKFJHTFRpbGUuZGVjb2Rlci53cml0ZShvcmlnaW4uc2xpY2UoMCwgNCkpLnJlcGxhY2UoUkdMVGlsZS50cmltLCAnJykpKSk7XHJcblx0XHRcdHRoaXMucmVzZXJ2ZWQgPSBvcmlnaW5bN107XHJcblx0XHR9IC8vY3RvclxyXG5cclxuXHJcblx0XHRwdWJsaWMgZ2V0IHNlcmlhbGl6ZSgpOiBCdWZmZXIge1xyXG5cdFx0XHRyZXR1cm4gQnVmZmVyLmZyb20odGhpcy5vcmlnaW4pO1xyXG5cdFx0fSAvL3NlcmlhbGl6ZVxyXG5cclxuXHRcdHB1YmxpYyBzdGF0aWMgcGFyc2UoY2h1bms6IFJlYWRvbmx5PEJ1ZmZlcj4pOiBSR0xUaWxlIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBSR0xUaWxlKGNodW5rKTtcclxuXHRcdH0gLy9wYXJzZVxyXG5cclxuXHJcblx0XHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMucHJlY2FsYztcclxuXHRcdH0gLy90b1N0cmluZ1xyXG5cclxuXHRcdHB1YmxpYyBbU3ltYm9sLnRvUHJpbWl0aXZlXShoaW50OiBzdHJpbmcpIHtcclxuXHRcdFx0aWYgKGhpbnQgPT09IFwic3RyaW5nXCIpIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XHJcblx0XHRcdGVsc2UgcmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdH0gLy9SR0xUaWxlXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlc3BvbnNpYmxlIGZvciBwYXJzaW5nIGFuZCBzdHJpcHBpbmcgQ2h1bmtzLlxyXG5cdCAqL1xyXG5cdGNsYXNzIFJHTE1hcCBpbXBsZW1lbnRzIFR5cGVzLkNvbnZlcnRhYmxlIHtcclxuXHJcblx0XHRwcml2YXRlIHN0YXRpYyByZWFkb25seSBNQUdJQzogQnVmZmVyID0gQnVmZmVyLmZyb20oWzB4MDMsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDFdKTtcclxuXHRcdHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IFJHTDogQnVmZmVyID0gQnVmZmVyLmZyb20oWzB4NTIsIDB4NDcsIDB4NEMsIDB4MDJdKTtcclxuXHRcdHByaXZhdGUgc3RhdGljIF9pZGNudHI6IG51bWJlciA9IDA7XHJcblxyXG5cdFx0cHJvdGVjdGVkIHJlYWRvbmx5IF9pZDogbnVtYmVyID0gUkdMTWFwLl9pZGNudHIrKztcclxuXHJcblxyXG5cdFx0cHJvdGVjdGVkIGNvbnN0cnVjdG9yKFxyXG5cdFx0XHRwcm90ZWN0ZWQgcmVzZXJ2ZWQ6IEJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygzLCAwKSxcclxuXHRcdFx0cHJvdGVjdGVkIHNpemU6IEJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygyLCAwKSxcclxuXHRcdFx0cHJvdGVjdGVkIHRpbGVzOiBSR0xUaWxlW10gPSBbIF0sXHJcblx0XHRcdHByb3RlY3RlZCB0cmFpbGluZzogQnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApLFxyXG5cdFx0XHRwcm90ZWN0ZWQgX2Zyb21GaWxlOiBzdHJpbmcgPSBcIlwiXHJcblx0XHQpIHtcclxuXHRcdFx0dGhpcy5fZnJvbUZpbGUgPSBwYXRoLnJlc29sdmUocGF0aC5ub3JtYWxpemUoX2Zyb21GaWxlKSk7XHJcblx0XHR9IC8vY3RvclxyXG5cclxuXHJcblx0XHRwdWJsaWMgZ2V0IHNlcmlhbGl6ZSgpOiBCdWZmZXIge1xyXG5cdFx0XHRsZXQgcmV0OiBCdWZmZXIgPSBCdWZmZXIuY29uY2F0KFt0aGlzLnJlc2VydmVkLCBSR0xNYXAuUkdMLCB0aGlzLnNpemVdKTtcclxuXHRcdFx0XHJcblx0XHRcdGZvciAobGV0IHRpbGUgb2YgdGhpcy50aWxlcykgcmV0ID0gQnVmZmVyLmNvbmNhdChbcmV0LCB0aWxlLnNlcmlhbGl6ZV0pO1xyXG5cclxuXHRcdFx0cmV0dXJuIEJ1ZmZlci5jb25jYXQoW3JldCwgUkdMTWFwLk1BR0lDLCB0aGlzLnRyYWlsaW5nIF0pO1xyXG5cdFx0fSAvL3NlcmlhbGl6ZVxyXG5cdFx0LyoqXHJcblx0XHQgKiBTdG9yZSAnVCcgdG8gd3JpdGFibGUgJ2ZpbGUnLlxyXG5cdFx0ICpcclxuXHRcdCAqIEBwYXJhbSBmaWxlIC0gVGFyZ2V0IGZpbGVcclxuXHRcdCAqL1xyXG5cdFx0cHVibGljIGFzeW5jIHNlcmlhbGl6ZUZpbGUoZmlsZTogUmVhZG9ubHk8c3RyaW5nPiA9IHRoaXMuX2Zyb21GaWxlKTogUHJvbWlzZTxCdWZmZXI+IHtcclxuXHRcdFx0bGV0IGRhdGE6IEJ1ZmZlcjtcclxuXHRcdFx0XHJcblx0XHRcdGF3YWl0IGZzLm91dHB1dEZpbGUoZmlsZSwgZGF0YSA9IHRoaXMuc2VyaWFsaXplLCB7XHJcblx0XHRcdFx0bW9kZTogMG83NTEsXHJcblx0XHRcdFx0ZW5jb2Rpbmc6IFwiYmluYXJ5XCIsXHJcblx0XHRcdFx0ZmxhZzogXCJ3XCJcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZGF0YTtcclxuXHRcdH0gLy9zZXJpYWxpemVGaWxlXHJcblx0XHRcclxuXHRcdHB1YmxpYyBzdGF0aWMgcGFyc2UoZGF0YTogUmVhZG9ubHk8QnVmZmVyPik6IFJHTE1hcCB7XHJcblx0XHRcdGRlYnVnKGBSR0xNYXAucGFyc2VgKTtcclxuXHJcblx0XHRcdGFzc2VydC5vayhCdWZmZXIuaXNCdWZmZXIoZGF0YSksIEVycm9ycy5FTk9CVUYpO1xyXG5cdFx0XHRhc3NlcnQub2soQnVmZmVyLmlzRW5jb2RpbmcoXCJiaW5hcnlcIiksIEVycm9ycy5FTk9CSU4pO1xyXG5cdFx0XHRhc3NlcnQub2soZGF0YS5sZW5ndGggPj0gOSwgRXJyb3JzLkVCQURCVUYpO1xyXG5cclxuXHRcdFx0Y29uc3QgbWFwOiBSR0xNYXAgPSBuZXcgUkdMTWFwKGRhdGEuc2xpY2UoMCwgMyksIGRhdGEuc2xpY2UoNywgOSkpO1xyXG5cclxuXHRcdFx0bGV0IGlkeDogbnVtYmVyID0gOTtcclxuXHJcblx0XHRcdHdoaWxlIChpZHggPCBkYXRhLmxlbmd0aCAmJiAhZGF0YS5zbGljZShpZHgsIGlkeCArIDUpLmVxdWFscyhSR0xNYXAuTUFHSUMpKVxyXG5cdFx0XHRcdG1hcC50aWxlcy5wdXNoKFJHTFRpbGUucGFyc2UoZGF0YS5zbGljZShpZHgsIGlkeCArPSA4KSkpO1xyXG5cclxuXHRcdFx0aWYgKGlkeCAhPSBkYXRhLmxlbmd0aCkgbWFwLnRyYWlsaW5nID0gZGF0YS5zbGljZShpZHggKyA1KTtcclxuXHJcblx0XHRcdHJldHVybiBtYXA7XHJcblx0XHR9IC8vcGFyc2VcclxuXHRcdC8qKlxyXG5cdFx0ICogUmVhZCBCdWZmZXIgZnJvbSAnZmlsZScuXHJcblx0XHQgKiBcclxuXHRcdCAqIEBwYXJhbSBmaWxlIC0gVGFyZ2V0IGZpbGVcclxuXHRcdCAqL1xyXG5cdFx0cHVibGljIHN0YXRpYyBhc3luYyBwYXJzZUZpbGUoZmlsZTogUmVhZG9ubHk8c3RyaW5nPik6IFByb21pc2U8UkdMTWFwPiB7XHJcblx0XHRcdGRlYnVnKGBSR0xNYXAucGFyc2VGaWxlOiAke2ZpbGV9YCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlcywgcmVqKSA9PiB7XHJcblx0XHRcdFx0ZGVidWdfdihgUkdMTWFwLnBhcnNlRmlsZTogQUNDRVNTYCk7XHJcblxyXG5cdFx0XHRcdGZzLmFjY2VzcyhmaWxlLCBmcy5jb25zdGFudHMuRl9PSyB8IGZzLmNvbnN0YW50cy5SX09LLCBlcnIgPT4ge1xyXG5cdFx0XHRcdFx0aWYgKGVycikge1xyXG5cdFx0XHRcdFx0XHRkZWJ1Z19lKGBSR0xNYXAucGFyc2VGaWxlOiAke2ZpbGV9IC0+IEVBQ0NFU1NgKTtcclxuXHJcblx0XHRcdFx0XHRcdHJlaihlcnIpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0ZGVidWdfdihgUkdMTWFwLnBhcnNlRmlsZTogUlNUUkVBTWApO1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc3Qgc3RyOiBmcy5SZWFkU3RyZWFtID0gZnMuY3JlYXRlUmVhZFN0cmVhbShmaWxlLCB7XHJcblx0XHRcdFx0XHRcdFx0ZmxhZ3M6IFwiclwiLFxyXG5cdFx0XHRcdFx0XHRcdGVuY29kaW5nOiBcImJpbmFyeVwiLFxyXG5cdFx0XHRcdFx0XHRcdG1vZGU6IGZzLmNvbnN0YW50cy5TX0lSVVNSIHwgZnMuY29uc3RhbnRzLlNfSVhHUlAsXHJcblx0XHRcdFx0XHRcdFx0ZW1pdENsb3NlOiB0cnVlXHJcblx0XHRcdFx0XHRcdH0pXHJcblx0XHRcdFx0XHRcdC5vbmNlKFwicmVhZGFibGVcIiwgYXN5bmMgKCkgPT4ge1xyXG5cdFx0XHRcdFx0XHRcdGRlYnVnX3YoYFJHTE1hcC5wYXJzZUZpbGU6ICR7ZmlsZX0gLT4gUmVhZGFibGUuYCk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGxldCBkYXRhOiBzdHJpbmcgPSAnJztcclxuXHJcblx0XHRcdFx0XHRcdFx0c3RyLnNldEVuY29kaW5nKFwiYmluYXJ5XCIpO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRmb3IgYXdhaXQgKGxldCBjaHVuayBvZiBzdHIpIGRhdGEgKz0gY2h1bms7XHJcblx0XHRcdFx0XHRcdFx0XHJcblx0XHRcdFx0XHRcdFx0c3RyLm9uY2UoXCJjbG9zZVwiLCAoKSA9PiB7XHJcblx0XHRcdFx0XHRcdFx0XHRjb25zdCBtYXA6IFJHTE1hcCA9IFJHTE1hcC5wYXJzZShCdWZmZXIuZnJvbShkYXRhLCBcImJpbmFyeVwiKSk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0bWFwLl9mcm9tRmlsZSA9IGZpbGU7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0cmVzKG1hcCk7XHJcblx0XHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0gLy9wYXJzZUZpbGVcclxuXHJcblxyXG5cdFx0cHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcblx0XHRcdHJldHVybiB0aGlzLnRpbGVzLm1hcCgodGlsZTogUkdMVGlsZSk6IHN0cmluZyA9PiB0aWxlLnRvU3RyaW5nKCkpLmpvaW4oJycpO1xyXG5cdFx0fSAvL3RvU3RyaW5nXHJcblxyXG5cdFx0cHVibGljIFtTeW1ib2wudG9QcmltaXRpdmVdKGhpbnQ6IHN0cmluZykge1xyXG5cdFx0XHRpZiAoaGludCA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcclxuXHRcdFx0ZWxzZSByZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0fSAvL1JHTE1hcFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXNwb25zaWJsZSBmb3IgY29udHJvbGxpbmcgdHJhbnNpdGlvbnMgYW5kIHNldHRpbmdzLlxyXG5cdCAqIFxyXG5cdCAqIFRPRE86IEFkZCBjb250cm9scy5cclxuXHQgKi9cclxuXHRleHBvcnQgY2xhc3MgUkdMIGV4dGVuZHMgZXZlbnQuRXZlbnRFbWl0dGVyIHtcclxuXHJcblx0XHRwcm90ZWN0ZWQgc3RhdGljIG1hcHBpbmdzX3M6IE1hcDxudW1iZXIsIE1hcHBpbmc+ID0gbmV3IE1hcDxudW1iZXIsIE1hcHBpbmc+KF9tYXBwaW5nc19zKTtcclxuXHJcblx0XHRwcm90ZWN0ZWQgc2VjdXJlU3dpdGNoOiBib29sZWFuID0gdHJ1ZTtcclxuXHRcdHByb3RlY3RlZCBiaW5kczogSU8gfCBudWxsID0gbnVsbDtcclxuXHJcblxyXG5cdFx0cHJvdGVjdGVkIGNvbnN0cnVjdG9yKFxyXG5cdFx0XHRhdXRvY29uZmlnOiBib29sZWFuID0gdHJ1ZSxcclxuXHRcdFx0cHVibGljIG1hcHBpbmdzX2M6IE1hcDxudW1iZXIsIE1hcHBpbmc+ID0gX21hcHBpbmdzX2MsXHJcblx0XHRcdHB1YmxpYyBtYXBwaW5nc19iOiBNYXA8bnVtYmVyLCBNYXBwaW5nPiA9IF9tYXBwaW5nc19iLFxyXG5cdFx0XHRwdWJsaWMgX01hcDogdHlwZW9mIFJHTE1hcCA9IFJHTE1hcCxcclxuXHRcdFx0cHVibGljIF9UaWxlOiB0eXBlb2YgUkdMVGlsZSA9IFJHTFRpbGVcclxuXHJcblx0XHQpIHtcclxuXHRcdFx0c3VwZXIoKTtcclxuXHJcblx0XHRcdGlmICghY2hhbGsuc3VwcG9ydHNDb2xvcikgY29uc29sZS53YXJuKFwiVGVybWluYWwgY29sb3JzIGFyZSBub3Qgc3VwcG9ydGVkIVwiKTtcclxuXHJcblx0XHRcdHRoaXMubWFwcGluZ3NfYyA9IG5ldyBNYXA8bnVtYmVyLCBNYXBwaW5nPihtYXBwaW5nc19jKTtcclxuXHRcdFx0dGhpcy5tYXBwaW5nc19iID0gbmV3IE1hcDxudW1iZXIsIE1hcHBpbmc+KG1hcHBpbmdzX2IpO1xyXG5cclxuXHRcdFx0aWYgKGF1dG9jb25maWcpIHtcclxuXHRcdFx0XHRQcm9taXNlLmFsbChbXHJcblx0XHRcdFx0XHR0aGlzLmxvYWRNYXBwaW5nc19jKCksXHJcblx0XHRcdFx0XHR0aGlzLmxvYWRNYXBwaW5nc19iKClcclxuXHRcdFx0XHRdKS5jYXRjaCgoKSA9PiBkZWJ1Z19lKFwiUkdMLmF1dG9jb25mOiBFTUFQUElOR1wiKSkudGhlbigoKSA9PiB7XHJcblx0XHRcdFx0XHR0aGlzLl9UaWxlLm1hcHBpbmdzX2MgPSB0aGlzLm1hcHBpbmdzX2M7XHJcblx0XHRcdFx0XHR0aGlzLl9UaWxlLm1hcHBpbmdzX2IgPSB0aGlzLm1hcHBpbmdzX2I7XHJcblxyXG5cdFx0XHRcdFx0ZGVidWcoXCJSR0wuY3RvciBkZWZmZXJlZCBtYXBwaW5ncy5cIik7XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdHRoaXMuYmluZCgpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLl9UaWxlLm1hcHBpbmdzX2MgPSB0aGlzLm1hcHBpbmdzX2M7XHJcblx0XHRcdHRoaXMuX1RpbGUubWFwcGluZ3NfYiA9IHRoaXMubWFwcGluZ3NfYjtcclxuXHRcdFx0dGhpcy5fVGlsZS5tYXBwaW5nc19zID0gUkdMLm1hcHBpbmdzX3M7XHJcblx0XHR9IC8vY3RvclxyXG5cclxuXHJcblx0XHRwdWJsaWMgYXN5bmMgbG9hZE1hcHBpbmdzX2MocGF0aD86IFJlYWRvbmx5PHN0cmluZz4pOiBQcm9taXNlPE1hcDxudW1iZXIsIE1hcHBpbmc+PjtcclxuXHRcdHB1YmxpYyBsb2FkTWFwcGluZ3NfYyhtYXA/OiBSZWFkb25seTxNYXA8bnVtYmVyLCBNYXBwaW5nPj4pOiBQcm9taXNlPE1hcDxudW1iZXIsIE1hcHBpbmc+PjtcclxuXHRcdHB1YmxpYyBsb2FkTWFwcGluZ3NfYyhtYXA6IFJlYWRvbmx5PHN0cmluZyB8IE1hcDxudW1iZXIsIE1hcHBpbmc+PiA9IFwiUkdMTWFwcGluZ3NfYy5qc1wiKTogUHJvbWlzZTxNYXA8bnVtYmVyLCBNYXBwaW5nPj4ge1xyXG5cdFx0XHR0aGlzLmVtaXQoXCJfbG9hZENvbG9yc1wiLCBtYXApO1xyXG5cclxuXHRcdFx0cmV0dXJuIFJHTC5sb2FkTWFwcGluZ3MobWFwLCB0aGlzLm1hcHBpbmdzX2MpO1xyXG5cdFx0fSAvL2xvYWRNYXBwaW5nc19jXHJcblxyXG5cdFx0cHVibGljIGFzeW5jIGxvYWRNYXBwaW5nc19iKHBhdGg/OiBSZWFkb25seTxzdHJpbmc+KTogUHJvbWlzZTxNYXA8bnVtYmVyLCBNYXBwaW5nPj47XHJcblx0XHRwdWJsaWMgbG9hZE1hcHBpbmdzX2IobWFwPzogUmVhZG9ubHk8TWFwPG51bWJlciwgTWFwcGluZz4+KTogUHJvbWlzZTxNYXA8bnVtYmVyLCBNYXBwaW5nPj47XHJcblx0XHRwdWJsaWMgbG9hZE1hcHBpbmdzX2IobWFwOiBSZWFkb25seTxzdHJpbmcgfCBNYXA8bnVtYmVyLCBNYXBwaW5nPj4gPSBcIlJHTE1hcHBpbmdzX2IuanNcIik6IFByb21pc2U8TWFwPG51bWJlciwgTWFwcGluZz4+IHtcclxuXHRcdFx0dGhpcy5lbWl0KFwiX2xvYWRCYWNrZ3JvdW5kXCIsIG1hcCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gUkdMLmxvYWRNYXBwaW5ncyhtYXAsIHRoaXMubWFwcGluZ3NfYik7XHJcblx0XHR9IC8vbG9hZE1hcHBpbmdzX2NcclxuXHRcdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBJbmNsdWRlIGN1c3RvbSBtYXBwaW5ncy5cclxuXHRcdCAqIFxyXG5cdFx0ICogQHBhcmFtIG1hcCAtIExvYWQgbmV3IG1hcHBpbmdzXHJcblx0XHQgKiBAcGFyYW0gb3JpZyAtIE1hcHBpbmdzIHRvIG92ZXJyaWRlXHJcblx0XHQgKi9cclxuXHRcdHB1YmxpYyBzdGF0aWMgYXN5bmMgbG9hZE1hcHBpbmdzKG1hcDogUmVhZG9ubHk8c3RyaW5nIHwgTWFwPG51bWJlciwgTWFwcGluZz4+LCBvcmlnOiBNYXA8bnVtYmVyLCBNYXBwaW5nPik6IFByb21pc2U8TWFwPG51bWJlciwgTWFwcGluZz4+IHtcclxuXHRcdFx0ZGVidWcoXCJSR0wubG9hZE1hcHBpbmdzOlwiLCB1dGlsLmluc3BlY3Qob3JpZywgeyBicmVha0xlbmd0aDogSW5maW5pdHkgfSkpO1xyXG5cclxuXHRcdFx0aWYgKHR5cGVvZiBtYXAgPT09IFwic3RyaW5nXCIpIHtcclxuXHRcdFx0XHRkZWxldGUgcmVxdWlyZS5jYWNoZVtyZXF1aXJlLnJlc29sdmUobWFwKV07XHJcblxyXG5cdFx0XHRcdGNvbnN0IGRhdGE6IE1hcDxudW1iZXIsIE1hcHBpbmc+ID0gcmVxdWlyZShtYXApO1xyXG5cclxuXHRcdFx0XHRmb3IgKGxldCBzaWcgb2YgZGF0YSkgb3JpZy5zZXQoc2lnWzBdLCBzaWdbMV0pO1xyXG5cdFx0XHR9IGVsc2UgaWYgKG1hcCBpbnN0YW5jZW9mIE1hcCkge1xyXG5cdFx0XHRcdGZvciAobGV0IHNpZyBvZiBtYXApIG9yaWcuc2V0KHNpZ1swXSwgc2lnWzFdKTtcclxuXHRcdFx0fSBlbHNlIHRocm93IEVycm9ycy5FQkFEVFBZRTtcclxuXHJcblx0XHRcdHJldHVybiBvcmlnO1xyXG5cdFx0fSAvL2xvYWRNYXBwaW5nc1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQmluZCB0aGUgUkdMIGVuZ2luZSB0byBJL08uXHJcblx0XHQgKiBcclxuXHRcdCAqIEBwYXJhbSBpbnAgLSBUaGUgdGFyZ2V0IHVzZXItaW5wdXQgc3RyZWFtIHRvIGJpbmQsIG11c3QgYmUgYSBUVFlcclxuXHRcdCAqIEBwYXJhbSBvdXQgLSBUaGUgdGFyZ2V0IHVzZXItaW5wdXQgc3RyZWFtIHRvIGJpbmQsIG11c3QgYmUgYSBUVFlcclxuXHRcdCAqL1xyXG5cdFx0YmluZChpbnA6IHR0eS5SZWFkU3RyZWFtID0gKHRoaXMuYmluZHMgPyB0aGlzLmJpbmRzLmlucHV0IDogcHJvY2Vzcy5zdGRpbikgfHwgcHJvY2Vzcy5zdGRpbiwgb3V0OiB0dHkuV3JpdGVTdHJlYW0gPSAodGhpcy5iaW5kcyA/IHRoaXMuYmluZHMub3V0cHV0IDogcHJvY2Vzcy5zdGRvdXQpIHx8IHByb2Nlc3Muc3Rkb3V0KTogdGhpcyB7XHJcblx0XHRcdGRlYnVnKFwiUkdMLmJpbmQ6IFwiICsgdGhpcy5iaW5kcyk7XHJcblxyXG5cdFx0XHRhc3NlcnQub2soaW5wLmlzVFRZICYmIG91dC5pc1RUWSwgRXJyb3JzLkVOT1RUWSk7XHJcblxyXG5cdFx0XHRpZiAoISF0aGlzLmJpbmRzICYmICEhdGhpcy5iaW5kcyEuaW5wdXQpIHtcclxuXHRcdFx0XHRkZWJ1ZyhcIlJHTC5iaW5kIHVuYm91bmQuXCIpO1xyXG5cclxuXHRcdFx0XHR0aGlzLmJpbmRzIS5pbnB1dC5zZXRSYXdNb2RlKGZhbHNlKTtcclxuXHRcdFx0XHRpZiAoISF0aGlzLmJpbmRzIS5faW5wQ2IpIHRoaXMuYmluZHMhLmlucHV0LnJlbW92ZUxpc3RlbmVyKFwiZGF0YVwiLCB0aGlzLmJpbmRzIS5faW5wQ2IpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmJpbmRzID0gPElPPntcclxuXHRcdFx0XHRpbnB1dDogaW5wLFxyXG5cdFx0XHRcdG91dHB1dDogb3V0LFxyXG5cdFx0XHRcdGVycm9yOiBwcm9jZXNzLnN0ZGVyclxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0dGhpcy5iaW5kcyEuaW5wdXQuc2V0UmF3TW9kZSh0cnVlKTtcclxuXHJcblx0XHRcdHRoaXMuYmluZHMhLmlucHV0Lm9uKFwiZGF0YVwiLCB0aGlzLmJpbmRzIS5faW5wQ2IgPSBkYXRhID0+IHtcclxuXHRcdFx0XHR0aGlzLmVtaXQoXCJyYXdrZXlcIiwgZGF0YSk7XHJcblx0XHRcdFx0dGhpcy5lbWl0KFwia2V5XCIsIGRhdGEudG9TdHJpbmcoKSk7XHJcblxyXG5cdFx0XHRcdGlmICh0aGlzLnNlY3VyZVN3aXRjaCAmJiBkYXRhLnRvU3RyaW5nKCkgPT09ICdcXHUwMDAzJykge1xyXG5cdFx0XHRcdFx0dGhpcy5lbWl0KFwiX2V4aXRcIik7XHJcblx0XHRcdFx0XHRwcm9jZXNzLmV4aXQoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9IC8vYmluZFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogU3RhcnQgYW4gaW5zdGFuY2Ugb2YgUkdMLlxyXG5cdFx0ICogXHJcblx0XHQgKiBAcGFyYW0ge2FueVtdfSBwYXJhbXMgLSBPcHRpb25zIHBhc3NlZCB0byBjb25zdHJ1Y3RvclxyXG5cdFx0ICovXHJcblx0XHRwdWJsaWMgc3RhdGljIGNyZWF0ZSguLi5wYXJhbXM6IFJlYWRvbmx5QXJyYXk8YW55Pik6IFJHTCB7XHJcblx0XHRcdHJldHVybiBuZXcgUkdMKC4uLnBhcmFtcyk7XHJcblx0XHR9IC8vY3JlYXRlXHJcblxyXG5cdH0gLy9SR0xcclxuXHJcbn0gLy9yZ2xcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHJnbDtcclxuIl19